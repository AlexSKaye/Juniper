module Vector
open(Prelude, List, Math)
export(vector, x, y, z, add, subtract, scale, dot, magnitude2, magnitude,
angle, cross, make, get, multiply)

type vector<'a;n> = { data : 'a[n] }

let x : uint8 = 0
let y : uint8 = 1
let z : uint8 = 2

fun make<'a;n>(d : 'a[n]) : vector<'a;n> =
    vector<'a;n> { data = d }

fun get<'a;n>(v : vector<'a;n>, i : uint32) : 'a =
    v.data[i]

fun add<'a;n>(v1 : vector<'a;n>, v2 : vector<'a;n>) : vector<'a;n> = (
    let mutable result = v1;
    for i : uint32 in 0 to n - 1 do
        set result.data[i] = result.data[i] + v2.data[i]
    end;
    result
)

fun zero<'a;n>() : vector<'a;n> =
    vector<'a;n>{ data = array 'a[n] of 0 end }

fun subtract<'a;n>(v1 : vector<'a;n>, v2 : vector<'a;n>) : vector<'a;n> = (
    let mutable result = v1;
    for i : uint32 in 0 to n - 1 do
        set result.data[i] = result.data[i] - v2.data[i]
    end;
    result
)

fun scale<'a;n>(v : vector<'a;n>, scalar : 'a) : vector<'a;n> = (
    let mutable result = v;
    for i : uint32 in 0 to n - 1 do
        set result.data[i] = result.data[i] * scalar
    end;
    result
)

fun divide<'a;n>(v : vector<'a;n>, divisor : 'a) : vector<'a;n> = (
    let mutable result = v;
    for i : uint32 in 0 to n - 1 do
        set result.data[i] = result.data[i] / divisor
    end;
    result
)

fun dot<'a;n>(v1 : vector<'a;n>, v2 : vector<'a;n>) : 'a = (
    let mutable sum : 'a = 0;
    for i : uint32 in 0 to n - 1 do
        set sum = sum + (v1.data[i] * v2.data[i])
    end;
    sum
)

fun magnitude2<'a;n>(v : vector<'a;n>) : 'a = (
    let mutable sum : 'a = 0;
    for i : uint32 in 0 to n - 1 do
        set sum = sum + (v.data[i] * v.data[i])
    end;
    sum
)

fun magnitude<'a;n>(v : vector<'a;n>) : double =
    sqrt_(magnitude2<'a;n>(v))

fun multiply<'a;n>(u : vector<'a;n>, v : vector<'a;n>) : vector<'a;n> = (
    let mutable result = u;
    for i : uint32 in 0 to n - 1 do
        set result.data[i] = result.data[i] * v.data[i]
    end;
    result
)

fun normalize<'a;n>(v : vector<'a;n>) : vector<'a;n> = (
    let mag = magnitude<'a;n>(v);
    if mag > 0 then (
        let mutable result = v;
        for i : uint32 in 0 to n - 1 do
            set result.data[i] = result.data[i] / mag
        end;
        result
    ) else
        v
    end
)

fun angle<'a;n>(v1 : vector<'a;n>, v2 : vector<'a;n>) : double =
    acos_(dot<'a;n>(v1, v2)/sqrt_(magnitude2<'a;n>(v1)*magnitude2<'a;n>(v2)))

fun cross<'a>(u : vector<'a;3>, v : vector<'a;3>) : vector<'a;3> =
    vector<'a;3>{data=[(u.data[1]*v.data[2]) - (u.data[2]*v.data[1]),
                       (u.data[2]*v.data[0]) - (u.data[0]*v.data[2]),
                       (u.data[0]*v.data[1]) - (u.data[1]*v.data[0])]}

// a onto b
fun project<'z;n>(a : vector<'z;n>, b : vector<'z;n>) : vector<'z;n> = (
    let bn = normalize<'z;n>(b);
    scale<'z;n>(bn, dot<'z;n>(a, bn))
)

fun projectPlane<'z;n>(a : vector<'z;n>, m : vector<'z;n>) : vector<'z;n> =
    subtract<'z;n>(a, project<'z;n>(a, m))
