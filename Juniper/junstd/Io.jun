module Io
open(Prelude)
export(digWrite, digRead, anaRead, anaWrite, pinStateToInt, intToPinState, pinState, mode, high, low, input, output, inputPullup, setPinMode, pinModeToInt, intToPinMode)

(*
    Interface: Io
*)

(*
    Type: pinState

    | pinState

    Constructors:
        - <high>
        - <low>
*)
(*
    Function: high

    Type Signature:
    | () -> pinState
*)
(*
    Function: low

    Type Signature:
    | () -> pinState
*)
type pinState = high | low

type mode = input | output | inputPullup

(*
    Function: write

    Writes a string to the serial output.

    Type signature:
    | <;n>(list<uint8; n>) -> unit

    Parameters:
        str : list<uint8; n> - The string to write

    Returns:
        Unit
*)
fun write<;n>(str : list<uint8; n>) : unit =
    #Serial.write(&str.data);#

(*
    
*)
fun pinStateToInt(value : pinState) : uint8 =
    case value of
    | low() => 0
    | high() => 1
    end

fun intToPinState(value : uint8) : pinState =
    if value == 0 then
        low()
    else
        high()
    end

fun digWrite(pin : uint16, value : pinState) : unit = (
    let intVal = pinStateToInt(value);
    #digitalWrite(pin, intVal);#
)

fun digRead(pin : uint16) : pinState = (
    let intVal : uint8 = 0;
    #intVal = digitalRead(pin);#;
    intToPinState(intVal)
)

fun anaRead(pin : uint16) : uint16 = (
    let value : uint16 = 0;
    #value = analogRead(pin);#;
    value
)

fun anaWrite(pin : uint16, value : uint8) : unit =
    #analogWrite(pin, value);#

fun pinModeToInt(m : mode) : uint8 =
    case m of
    | input() => 0
    | output() => 1
    | inputPullup() => 2
    end

fun intToPinMode(m : uint8) : mode =
    case m of
    | 0 => input()
    | 1 => output()
    | 2 => inputPullup()
    end

fun setPinMode(pin : uint32, m : mode) : unit = (
    let m2 = pinModeToInt(m);
    #pinMode(pin, m2);#
)