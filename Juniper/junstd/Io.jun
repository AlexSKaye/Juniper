module Io
open(Prelude)
export(digWrite, digRead, anaRead, anaWrite, pinStateToInt, intToPinState,
pinState, mode, high, low, input, output, inputPullup, setPinMode, pinModeToInt,
intToPinMode, toggle, digIn, anaIn, digOut, anaOut, risingEdge, fallingEdge,
edge)

(*
    Interface: Io
*)

(*
    Type: pinState

    | pinState

    Constructors:
        - <high>
        - <low>
*)
(*
    Function: high

    Type Signature:
    | () -> pinState
*)
(*
    Function: low

    Type Signature:
    | () -> pinState
*)
type pinState = high | low

type mode = input | output | inputPullup

fun toggle(p : pinState) : pinState =
    case p of
    | high() => low()
    | low() => high()
    end

(*
    Function: write

    Writes a string to the serial output.

    Type signature:
    | <;n>(list<uint8; n>) -> unit

    Parameters:
        str : list<uint8; n> - The string to write

    Returns:
        Unit
*)
fun write<;n>(str : list<uint8; n>) : unit =
    #Serial.write(&str.data);#

(*

*)
fun pinStateToInt(value : pinState) : uint8 =
    case value of
    | low() => 0
    | high() => 1
    end

fun intToPinState(value : uint8) : pinState =
    if value == 0 then
        low()
    else
        high()
    end

fun digWrite(pin : uint16, value : pinState) : unit = (
    let intVal = pinStateToInt(value);
    #digitalWrite(pin, intVal);#
)

fun digRead(pin : uint16) : pinState = (
    let intVal : uint8 = 0;
    #intVal = digitalRead(pin);#;
    intToPinState(intVal)
)

fun digIn(pin : uint16) : sig<pinState> =
    signal<pinState>(just<pinState>(digRead(pin)))

fun digOut(pin : uint16, sig : sig<pinState>) : unit =
    Signal:sink<pinState>(fn (value : pinState) : unit -> digWrite(pin, value), sig)

fun anaRead(pin : uint16) : uint16 = (
    let value : uint16 = 0;
    #value = analogRead(pin);#;
    value
)

fun anaWrite(pin : uint16, value : uint8) : unit =
    #analogWrite(pin, value);#

fun anaIn(pin : uint16) : sig<uint16> =
    signal<uint16>(just<uint16>(anaRead(pin)))

fun anaOut(pin : uint16, sig : sig<uint16>) : unit =
    Signal:sink<uint16>(fn (value : uint16) : unit -> anaWrite(pin, value), sig)

fun risingEdge(sig : sig<pinState>, prevState : pinState ref) : sig<pinState> =
    Signal:filter<pinState>(fn (currState : pinState) : bool ->
        case (currState, !prevState) of
        | (high(), low()) => false
        | _ => true
        end
    , sig)

fun fallingEdge(sig : sig<pinState>, prevState : pinState ref) : sig<pinState> =
    Signal:filter<pinState>(fn (currState : pinState) : bool ->
        case (currState, !prevState) of
        | (low(), high()) => false
        | _ => true
        end
    , sig)

fun edge(sig : sig<pinState>, prevState : pinState ref) : sig<pinState> =
    Signal:filter<pinState>(fn (currState : pinState) : bool ->
        case (currState, !prevState) of
        | (high(), low()) => false
        | (low(), high()) => false
        | _ => true
        end
    , sig)

fun pinModeToInt(m : mode) : uint8 =
    case m of
    | input() => 0
    | output() => 1
    | inputPullup() => 2
    end

fun intToPinMode(m : uint8) : mode =
    case m of
    | 0 => input()
    | 1 => output()
    | 2 => inputPullup()
    end

fun setPinMode(pin : uint32, m : mode) : unit = (
    let m2 = pinModeToInt(m);
    #pinMode(pin, m2);#
)
