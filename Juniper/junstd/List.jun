module List
open(Prelude)
export(map, foldl, foldr, append, nth, flatten, resize, all, any, pushFront, pushBack,
replicate, setNth)

(* The goal of this module is to provide reusable functions that run as quickly
   as possible. This means that most of the functions in this module are written
   in an imperative style. *)

(*
    Interface: List
*)

(*
    Function: map

    Applies f to every element of the list and returns the new list.

    Type Signature:
    | <'a,'b;n>(('a) -> 'b, list<'a; n>) -> list<'b; n>

    Parameters:
        f : ('a) -> 'b - The mapping function
        lst : list<'t;aCap> - The list to map.

   Returns:
        The list obtained by applying f to every element of lst.
*)
fun map<'a,'b;n>(f : ('a) -> 'b, lst : list<'a; n>) : list<'b; n> = (
    let mutable ret = array 'b[n] end;
    for i : uint32 in 0 to lst.length - 1 do
        set ret[i] = f(lst.data[i])
    end;
    list<'b;n>{data=ret; length=lst.length}
)

(*
    Function: foldl

    Applies a function f to each element of the list, threading an accumulator
    argument through the computation.

    Type Signature:
    | <'t,'state;n>(('t, 'state) -> 'state, 'state, list<'t; n>) -> 'state

    Parameters:
        f : ('t, 'state) -> 'state - The function to update the state given the input elements.
        initState : 'state - The initial state.
        lst : list<'t; n> - The input list.

    Returns:
        The final state value.
*)
fun foldl<'t,'state;n>(f : ('t, 'state) -> 'state, initState : 'state, lst : list<'t; n>) : 'state = (
    let mutable s = initState;
    for i : uint32 in 0 to lst.length - 1 do
        set s = f(lst.data[i], s)
    end;
    s
)

(*
    Function: foldr

    Applies a function f to each element of the list in reverse order, threading
    an accumulator argument through the computation.

    Type Signature:
    | <'t,'state;n>(('t, 'state) -> 'state, 'state, list<'t; n>) -> 'state

    Parameters:
        f : ('t,'state) -> 'state - The function to update the state given the
                                     input elements.
        initState : 'state - The initial state.
        lst : list<'t; n> - The input list.

    Returns:
        The final state value.
*)
fun foldr<'t,'state;n>(f : ('t, 'state) -> 'state, initState : 'state, lst : list<'t; n>) : 'state = (
    let mutable s = initState;
    for i : uint32 in lst.length - 1 downto 0 do
        set s = f(lst.data[i], s)
    end;
    s
)

(*
    Function: append

    Appends two lists.

    Type Signature:
    | <'t;aCap,bCap,retCap>(list<'t;aCap>, list<'t;bCap>) -> list<'t;retCap>

    Parameters:
        lstA : list<'t;aCap> - The first list.
        lstB : list<'t;bCap> - The second list.

   Returns:
        The two lists appended together.
*)
fun append<'t;aCap,bCap,retCap>(lstA : list<'t;aCap>, lstB : list<'t;bCap>) : list<'t;retCap> = (
    let mutable j : uint32 = 0;
    let mutable out = list<'t;retCap>{data=array 't[retCap] end;
                                      length=lstA.length + lstB.length};
    for i : uint32 in 0 to lstA.length - 1 do (
        set out.data[j] = lstA.data[i];
        set j = j + 1
    ) end;
    for i : uint32 in 0 to lstB.length - 1 do (
        set out.data[j] = lstB.data[i];
        set j = j + 1
    ) end;
    out
)

(*
    Function: nth

    Returns the nth element of the given list

    Type Signature:
    | <'t;n>(uint32, list<'t;n>) -> 't

    Parameters:
        i : uint32 - The index of the element to be retrieved
        lst : list<'t;n> - The given list

    Returns:
        The element at position i in the list
*)
fun nth<'t;n>(i : uint32, lst : list<'t;n>) : 't =
    lst.data[i]

(*
    Function: flatten

    Flattens a list of lists into a single list.

    Type Signature:
    | <'t;p,q>(list<list<'t;m>;n>) -> list<'t;n*m>

    Parameters:
        listOfLists : list<list<'t;p>;q> - The list of lists

    Returns:
        The flattened list
*)

fun flatten<'t;m,n>(listOfLists : list<list<'t;m>;n>) : list<'t;m*n> = (
    let mutable ret = array 't[m*n] end;
    let mutable index : uint32 = 0;
    for i : uint32 in 0 to listOfLists.length - 1 do
        for j : uint32 in 0 to listOfLists.data[i].length - 1 do
            (set ret[index] = listOfLists.data[i].data[j];
            set index = index + 1)
        end
    end;
    list<'t;m*n>{data=ret; length=index}
)


(*
    Function: resize

    Creates a copy of the list which has a new capacity m. The contents and
    length of the list remained unchanged.

    Type Signature:
    | <'t;n,m>(list<'t;n>) -> list<'t;m>

    Parameters:
        lst : list<'t;n> - The list to resize

    Returns:
        The new list with capacity m
*)
fun resize<'t;n,m>(lst : list<'t;n>) : list<'t;m> = (
    let mutable ret = array 't[m] end;
    for i : uint32 in 0 to lst.length - 1 do
        set ret[i] = lst.data[i]
    end;
    list<'t;m>{data=ret; length=lst.length}
)

(*
    Function: all

    Returns true if pred(elem) returns true for all elements elem in lst,
    otherwise false.

    Type Signature:
    | <'t;n>(('t) -> bool, list<'t;n>) -> bool

    Parameters:
        pred : ('t) -> bool - The predicate which must be satisfied
        lst : list<'t;n> - The list on which the predicate is checked

    Returns:
        A boolean value which determines if pred satsified for every element of
        lst.
*)
fun all<'t;n>(pred : ('t) -> bool, lst : list<'t;n>) : bool = (
    let mutable satisfied = true;
    for i : uint32 in 0 to lst.length - 1 do
        if satisfied then
            (set satisfied = pred(lst.data[i]);
            ())
        else
            ()
        end
    end;
    satisfied
)

(*
    Function: any

    Returns true if pred(elem) returns true for at least one element elem in
    lst, otherwise false.

    Type Signature:
    | <'t;n>(('t) -> bool, list<'t;n>) -> bool

    Parameters:
        pred : ('t) -> bool - The predicate which must be satisfied
        lst : list<'t;n> - The list on which the predicate is checked

    Returns:
        A boolean value which determines if pred is satsified for some element
        of lst.
*)
fun any<'t;n>(pred : ('t) -> bool, lst : list<'t;n>) : bool = (
    let mutable satisfied = false;
    for i : uint32 in 0 to lst.length - 1 do
        if not satisfied then
            (set satisfied = pred(lst.data[i]);
            ())
        else
            ()
        end
    end;
    satisfied
)

(*
    Function: pushBack

    Returns a copy of the given list with the element appended to the end.

    Type Signature:
    | <'t;n>('t, list<'t;n>) -> list<'t;n>

    Parameters:
        elem : 't - The element to add to the end of the list
        lst : list<'t;n> - The list

    Returns:
        A copy of lst with elem appended to the end
*)
fun pushBack<'t;n>(elem : 't, lst : list<'t;n>) : list<'t;n> = (
    if lst.length == n then
        lst
    else (
        let mutable ret = lst;
        set ret.data[lst.length] = elem;
        set ret.length = lst.length + 1;
        ret
    ) end
)

(*
    Function: pushFront

    Returns a copy of the given list with the element appended to the front.

    Type Signature:
    | <'t;n>('t, list<'t;n>) -> list<'t;n>

    Parameters:
        elem : 't - The element to add to the front of the list
        lst : list<'t;n> - The list

    Returns:
        A copy of lst with elem appended to the front
*)
fun pushFront<'t;n>(elem : 't, lst : list<'t;n>) : list<'t;n> = (
    let mutable ret = lst;
    for i : uint32 in n - 2 downto 0 do
        set ret.data[i + 1] = ret.data[i]
    end;
    set ret.data[0] = elem;
    if ret.length == n then
        ret
    else
        (set ret.length = lst.length + 1;
        ret)
    end
)

(*
    Function: setNth

    Returns a copy of the given list where the element at the given index
    is the given element.

    Type Signature:
    | <'t;n>(uint32, 't, list<'t;n>) -> list<'t;n>

    Parameters:
        index : uint32 - The index to set
        elem : 't - The new element
        lst : list<'t;n> - The list

    Returns:
        A new list where the elem is at index.
*)
fun setNth<'t;n>(index : uint32, elem : 't, lst : list<'t;n>) : list<'t;n> =
    if lst.length <= index then
        lst
    else
        (let mutable ret = lst;
        set ret.data[index] = elem;
        ret)
    end

(*
    Function: replicate

    Initializes a new list of a given length using the given element.

    Type Signature:
    | <'t;n>(uint32, 't) -> list<'t;n>

    Parameters:
        numOfElements : uint32 - The length of the new list
        elem : 't - The element to replicate

    Returns:
        A new list with elem at every position in the list.
*)
fun replicate<'t;n>(numOfElements : uint32, elem : 't) : list<'t;n> = (
    list<'t;n> {
        data = array 't[n] of elem end;
        length = numOfElements
    }
)
