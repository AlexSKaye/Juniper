module List

/* The goal of this module is to provide reusable functions that run as quickly
   as possible. This means that most of the functions in this module are written
   in an imperative style. */

/*
    Interface: List
*/

/*
    Function: map

    Applies f to every element of the list and returns the new list.

    Type Signature:
    | (||)((closure)(a) -> b, list<a, n>) -> list<b, n>

    Parameters:
        f : (closure)(a) -> b - The mapping function
        lst : list<t, n> - The list to map.

   Returns:
        The list obtained by applying f to every element of lst.
*/
fun map(f : (closure)(a) -> b, lst : list<a, n>) : list<b, n> = {
    let mut ret = array b[n]
    for (i : uint32 in 0u32 to lst.length) {
        ret[i] = f(lst.data[i])
    }
    {data := ret, length := lst.length}
}

/*
    Function: foldl

    Applies a function f to each element of the list, threading an accumulator
    argument through the computation.

    Type Signature:
    | (||)((closure)(t, state) -> state, state, list<t, n>) -> state

    Parameters:
        f : (closure)(t, state) -> state - The function to update the state given the input elements.
        initState : state - The initial state.
        lst : list<t, n> - The input list.

    Returns:
        The final state value.
*/
fun foldl(f : (closure)(t, state) -> state, initState : state, lst : list<t, n>) : state = {
    let mut s = initState
    for (i : uint32 in 0u32 to lst.length) {
        s = f(lst.data[i], s)
    }
    s
}

/*
    Function: foldr

    Applies a function f to each element of the list in reverse order, threading
    an accumulator argument through the computation.

    Type Signature:
    | (||)((closure)(t, state) -> state, state, list<t, n>) -> state

    Parameters:
        f : (closure)(t,state) -> state - The function to update the state given the
                                     input elements.
        initState : state - The initial state.
        lst : list<t, n> - The input list.

    Returns:
        The final state value.
*/
fun foldr(f : (closure)(t, state) -> state, initState : state, lst : list<t, n>) : state =
    if (lst.length == 0) {
        initState
    } else {
        let mut s = initState
        let mut i : uint32 = lst.length
        do {
            i = i - 1
            s = f(lst.data[i], s)
        } while (i > 0u32)
        s
    }

/*
    Function: append

    Appends two lists.

    Type Signature:
    | (||)(list<t;aCap>, list<t;bCap>) -> list<t;retCap>

    Parameters:
        lstA : list<t;aCap> - The first list.
        lstB : list<t;bCap> - The second list.

   Returns:
        The two lists appended together.
*/
fun append(lstA : list<t, aCap>, lstB : list<t, bCap>) : list<t, retCap> = {
    let mut j : uint32 = 0u32
    let mut out = {data := array t[retCap], length := lstA.length + lstB.length}
    for (i : uint32 in 0u32 to lstA.length) {
        out.data[j] = (lstA.data[i] : t)
        j = j + 1u32
    }
    for (i : uint32 in 0u32 to lstB.length) {
        out.data[j] = (lstB.data[i] : t)
        j = j + 1u32
    }
    out
}

/*
    Function: nth

    Returns the nth element of the given list

    Type Signature:
    | (||)(uint32, list<t, n>) -> t

    Parameters:
        i : uint32 - The index of the element to be retrieved
        lst : list<t, n> - The given list

    Returns:
        The element at position i in the list
*/
fun nth(i : uint32, lst : list<t, n>) : t =
    if (i < (lst.length : uint32)) {
        lst.data[i]
    } else {
        quit<t>()
    }

/*
    Function: flattenSafe

    Flattens a list of lists into a single list.

    Type Signature:
    | (||)(list<list<t;m>, n>) -> list<t;m*n>

    Parameters:
        listOfLists : list<list<t;m>, n> - The list of lists

    Returns:
        The flattened list
*/

fun flattenSafe(listOfLists : list<list<t, m>, n>) : list<t, m*n> = {
    let mut ret = array t[m*n]
    let mut index = 0u32
    for (i : uint32 in 0u32 to listOfLists.length) {
        for (j : uint32 in 0u32 to listOfLists.data[i].length) {
            ret[index] = listOfLists.data[i].data[j]
            index = index + 1
        }
    }
    {data := ret, length := index}
}


/*
    Function: resize

    Creates a copy of the list which has a new capacity m. The contents and
    length of the list remained unchanged.

    Type Signature:
    | (||)(list<t, n>) -> list<t;m>

    Parameters:
        lst : list<t, n> - The list to resize

    Returns:
        The new list with capacity m
*/
fun resize(lst : list<t, n>) : list<t, m> = {
    let mut ret = array t[m]
    for (i : uint32 in 0u32 to lst.length) {
        ret[i] = lst.data[i]
    }
    {data := ret, length := lst.length}
}

/*
    Function: all

    Returns true if pred(elem) returns true for all elements elem in lst,
    otherwise false.

    Type Signature:
    | (||)((closure)(t) -> bool, list<t, n>) -> bool

    Parameters:
        pred : (closure)(t) -> bool - The predicate which must be satisfied
        lst : list<t, n> - The list on which the predicate is checked

    Returns:
        A boolean value which determines if pred satsified for every element of
        lst.
*/
fun all(pred : (closure)(t) -> bool, lst : list<t, n>) : bool = {
    let mut satisfied = true
    for (i : uint32 in 0u32 to lst.length) {
        if (satisfied) {
            satisfied = pred(lst.data[i])
        }
    }
    satisfied
}

/*
    Function: any

    Returns true if pred(elem) returns true for at least one element elem in
    lst, otherwise false.

    Type Signature:
    | (||)((closure)(t) -> bool, list<t, n>) -> bool

    Parameters:
        pred : (closure)(t) -> bool - The predicate which must be satisfied
        lst : list<t, n> - The list on which the predicate is checked

    Returns:
        A boolean value which determines if pred is satsified for some element
        of lst.
*/
fun any(pred : (closure)(t) -> bool, lst : list<t, n>) : bool = {
    let mut satisfied = false
    for (i : uint32 in 0u32 to lst.length) {
        if (!satisfied) {
            satisfied = pred(lst.data[i])
        }
    }
    satisfied
}

/*
    Function: pushBack

    Returns a copy of the given list with the element appended to the end.
    If the element will not fit in the list, the program crashes.

    Type Signature:
    | (||)(t, list<t, n>) -> list<t, n>

    Parameters:
        elem : t - The element to add to the end of the list
        lst : list<t, n> - The list

    Returns:
        A copy of lst with elem appended to the end
*/
fun pushBack(elem : t, lst : list<t, n>) : list<t, n> =
    if ((lst.length : uint32) >= n) {
        quit<list<t, n>>()
    } else {
        let mut ret = lst
        ret.data[lst.length : uint32] = elem
        ret.length = lst.length + 1u32
        ret
    }

/*
    Function: pushOffFront

    Returns a copy of the given list with the element appended to the front.
    If the list is already full then the last element is pushed off (removed)
    from the back of the list.

    Type Signature:
    | (||)(t, list<t, n>) -> list<t, n>

    Parameters:
        elem : t - The element to add to the front of the list
        lst : list<t, n> - The list

    Returns:
        A copy of lst with elem appended to the front
*/
fun pushOffFront(elem : t, lst : list<t, n>) : list<t, n> = {
    if (n <= 0i32) {
        lst
    } else {
        var ret : list<t, n>
        ret.data[0u32] = elem
        for (i : uint32 in 0 to lst.length) {
            if ((i + 1) < n) {
                ret.data[i + 1] = lst.data[i]
            }
        }
        if (lst.length == cast(n)) {
            ret.length = lst.length
        } else {
            ret.length = lst.length + 1
        }
        ret
    }
}

/*
    Function: setNth

    Returns a copy of the given list where the element at the given index
    is the given element. The index must be less than the length of the list.

    Type Signature:
    | (||)(uint32, t, list<t, n>) -> list<t, n>

    Parameters:
        index : uint32 - The index to set
        elem : t - The new element
        lst : list<t, n> - The list

    Returns:
        A new list where the elem is at index.
*/
fun setNth(index : uint32, elem : t, lst : list<t, n>) : list<t, n> =
    if (index < lst.length) {
        let mut ret = lst
        ret.data[index] = elem
        ret
    } else {
        lst
    }

/*
    Function: replicate

    Initializes a new list of a given length using the given element.

    Type Signature:
    | (||)(uint32, t) -> list<t, n>

    Parameters:
        numOfElements : uint32 - The length of the new list
        elem : t - The element to replicate

    Returns:
        A new list with elem at every position in the list.
*/
fun replicate(numOfElements : uint32, elem : t) : list<t, n> =
    {data := array t[n] of elem, length := numOfElements}

/*
    Function: remove

    Returns a copy of lst where the first element equal to elem is
    deleted, if there is such an element.

    Type Signature:
    | (||)(t, list<t, n>) -> list<t, n>

    Parameters:
        elem : t - The element to remove from the list
        lst : t - The list

    Returns:
        A copy of lst with elem removed.
*/
fun remove(elem : t, lst : list<t, n>) : list<t, n> = {
    let mut index : uint32 = 0u32
    let mut found = false
    for (i : uint32 in 0u32 to lst.length) {
        if ((!found) && (lst.data[i] == elem)) {
            index = i
            found = true
        }
    }
    if (found) {
        // Shift all the elements after the discovered index once to the left
        let mut ret = lst
        ret.length = lst.length - 1u32
        for (i : uint32 in index to lst.length - 1) {
            ret.data[i] = lst.data[i + 1]
        }
        ret
    } else {
        lst
    }
}

/*
    Function: dropLast

    Drops the last element of a List.

    Type Signature:
    | (||)(list<t, n>) -> list<t, n>

    Parameters:
        lst : list<t, n> - The list

    Returns:
        The list with the last element dropped
*/
fun dropLast(lst : list<t, n>) : list<t, n> =
    if (lst.length == 0u32) {
        lst
    } else {
        {
            data := lst.data,
            length := lst.length - 1u32
        }
    }

/*
    Function: foreach

    Calls f for each element in lst. This function is used for its side effects
    and the evaluation order is defined to be the same as the order of the
    elements in the list.

    Type Signature:
    | (||)((closure)(t) -> unit, list<t, n>) -> unit

    Parameters:
        f : (closure)(t) -> unit - The function to call
        lst : list<t, n> - The list

    Returns:
        Unit
*/
fun foreach(f : (closure)(t) -> unit, lst : list<t, n>) : unit =
    for (i : uint32 in 0u32 to lst.length) {
        f(lst.data[i])
    }

/*
    Function: last

    Returns the last element of the lst.

    Type Signature:
    | (||)(list<t, n>) -> maybe<t>

    Parameters:
        lst : list<t, n> - The list

    Returns:
        The last element of the list
*/
fun last(lst : list<t, n>) : maybe<t> =
    if (lst.length == 0) {
        nothing()
    } else {
        just(lst.data[lst.length - 1])
    }

/*
    Function: max_

    Returns the maximum element of the lst. If the list is empty, nothing() is returned.

    Type Signature:
    | (||)(list<t, n>) -> maybe<t> where t : num

    Parameters:
        lst : list<t, n> - The list

    Returns:
        The maximum element of the list
*/
fun max_(lst : list<t, n>) : maybe<t> where t : num =
    if ((lst.length == 0u32) || (n == 0i32)) {
        nothing()
    } else {
        let mut maxVal : t = lst.data[0u32]
        for (i : uint32 in 1u32 to lst.length) {
            if (lst.data[i] > maxVal) {
                maxVal = lst.data[i]
            }
        }
        just(maxVal)
    }


/*
    Function: min_

    Returns the minimum element of the lst. If the list is empty, nothing() is returned.

    Type Signature:
    | (||)(list<t, n>) -> maybe<t> where t : num

    Parameters:
        lst : list<t, n> - The list

    Returns:
        The minimum element of the list
*/
fun min_(lst : list<t, n>) : maybe<t> =
    if ((lst.length == 0u32) || (n == 0i32)) {
        nothing()
    } else {
        let mut minVal = lst.data[0u32]
        for (i : uint32 in 1u32 to lst.length) {
            if (lst.data[i] < minVal) {
                minVal = lst.data[i]
            }
        }
        just(minVal)
    }


/*
    Function: member

    Returns true if elem is a member of lst, otherwise false.

    Type Signature:
    | (||)(t, list<t, n>) -> bool

    Parameters:
        elem : t - The element to match
        lst : list<t, n> - The list to search

    Returns:
        True if elem is in the list, otherwise false.
*/
fun member(elem : t, lst : list<t, n>) : bool = {
    let mut found = false
    for (i : uint32 in 0u32 to lst.length) {
        if ((!found) && (lst.data[i] == elem)) {
            found = true
        }
    }
    found
}

/*
    Function: zip

    Zips two lists of equal length into one list of two-tuples, where the first
    element of each tuple is taken from the first list & the second element is
    taken from corresponding element in the second list. If the lists are not
    of equal length, the elements from the longer list are dropped.

    Type Signature:
    | (||)(list<a, n>, list<b, n>) -> list<(a,b), n>

    Parameters:
        lstA : list<a, n> - The first list to zip
        lstB : list<b, n> - The second list to zip

    Returns:
        The zipped lists.
*/
fun zip(lstA : list<a, n>, lstB : list<b, n>) : list<(a,b), n> = {
    let outLen = Math:min_(lstA.length, lstB.length)
    let mut ret = {
        data := array (a,b)[n],
        length := outLen
    }
    for (i : uint32 in 0u32 to outLen) {
        ret.data[i] = (lstA.data[i], lstB.data[i])
    }
    ret
}

/*
    Function: unzip

    Unzips a list of two-tuples into two lists, where the first list contains
    the first element of each tuple, & the second list contains the second
    element of each tuple.

    Type Signature:
    | (||)(list<(a*b), n>) -> (list<a, n>*list<b, n>)

    Parameters:
        lst : list<(a*b), n> - The list to unzip

    Returns:
        The two unzipped lists.
*/
fun unzip(lst : list<(a,b), n>) : (list<a, n>, list<b, n>) = {
    let mut retA = {
        data := array a[n],
        length := lst.length
    }
    let mut retB = {
        data := array b[n],
        length := lst.length
    }
    for (i : uint32 in 0u32 to lst.length) {
        let (a, b) = lst.data[i]
        retA.data[i] = a
        retB.data[i] = b
    }
    (retA, retB)
}

/*
    Function: sum

    Computes the sum of a list of numbers

    Type Signature:
    | (||)(list<a, n>) -> a where a : num

    Parameters:
        lst : list<a, n> - The list to sum

    Returns:
        The sum of the list
*/
fun sum(lst : list<a, n>) : a where a : num =
    List:foldl((+), 0, lst)

/*
    Function: average

    Computes the average (mean) of a list of numbers

    Type Signature:
    | (||)(list<a, n>) -> a where a : num

    Parameters:
        lst : list<a, n> - The list to average

    Returns:
        The numerical mean of the list
*/
fun average(lst : list<a, n>) : a where a : num =
    sum(lst) / cast(lst.length)
