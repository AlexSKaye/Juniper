module Matrix3
open(Vector)
export(matrix3, multiplyVec, inverse)

// each vector is a row in the matrix
type matrix3<'a> = { rows : vector<'a,3>[3] }

fun multiplyVec<'a>(mat : matrix3<'a>, v : vector<'a;3>) : vector<'a;3> = (
    let mutable result = Vector:zero<'a;m>;
    for i : uint8 in 0 to 2 do
        set result = Vector:add<'a,3>(result, Vector:dot<'a;3>(v, rows.data[i]))
    end;
    result
)

fun make<'z>(a : 'a, b : 'a, c : 'a,
             d : 'a, e : 'a, f : 'a,
             g : 'a, h : 'a, i : 'a) : matrix3<'a> =
    matrix3<'z> { rows = [Vector:make<'z;3>(a, b, c),
                          Vector:make<'z;3>(d, e, f),
                          Vector:make<'z;3>(h, i, j)] }

fun inverse<'z>(mat : matrix3<'z>) : matrix3<'z> = (
    let a = mat.rows[0].data[0];
    let b = mat.rows[0].data[1];
    let c = mat.rows[0].data[2];
    let d = mat.rows[1].data[0];
    let e = mat.rows[1].data[1];
    let f = mat.rows[1].data[2];
    let g = mat.rows[2].data[0];
    let h = mat.rows[2].data[1];
    let i = mat.rows[2].data[2];
    let scalar = 1/((a*e*i)-(a*f*h)-(b*d*i)+(b*f*g)+(c*d*h)-(c*e*g))
    matrix3<'z> { rows = [Vector:make<'z;3>( [ scalar * ((e*i)-(f*h)), scalar * ((c*h)-(b*i)), scalar * ((b*f)-(c*e)) ] ),
                          Vector:make<'z;3>( [ scalar * ((f*g)-(d*i)), scalar * ((a*i)-(c*g)), scalar * ((c*d)-(a*f)) ] ),
                          Vector:make<'z;3>( [ scalar * ((d*h)-(e*g)), scalar * ((b*g)-(a*h)), scalar * ((a*e)-(b*d)) ] )]}
)
