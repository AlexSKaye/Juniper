%{
%}

%start start

%token <int> INT
%token <float> FLOAT
%token <string> ID
%token <string> STRING
%token RECORD
%token RETURN
%token END
%token OPEN
%token EXPORT
%token MODULE
%token BREAK
%token FUN
%token IF
%token THEN
%token ELSE
%token ELIF
%token WHILE
%token DO
%token LET
%token VAR
%token FOR
%token LPAREN
%token RPAREN
%token LBRACK
%token RBRACK
%token LCURLYBRACE
%token RCURLYBRACE
%token COMMA
%token MOD
%token PLUS
%token MINUS
%token TIMES
%token DIVIDE
%token NOT
%token AND
%token OR
%token AMPERSAND
%token PIPE
%token TICK
%token TILDE
%token CASE
%token OF
%token TYPE
%token COLON
%token SEMICOLON
%token NOTEQUAL
%token EQUAL
%token GTHEN
%token LTHEN
%token GTHENEQ
%token LTHENEQ
%token UNIT
%token TRUE
%token FALSE
%token UNDERSCORE
%token DOT
%token EOF

%type < Module > start

%left SEMICOLON COMMA
%left EQUAL NETEQUAL
%left OR AND
%left UNDERSCORE
%left LTHEN LTHENEQ GTHEN GTHENEQ
%left PLUS MINUS PIPE
%left TIMES DIVIDE MOD AMPERSAND
%left NOT TILDE
%left ID
%left DOT
%left LBRACK
%left LPAREN RPAREN

%%

start:
  | declaration_list { Module $1 }

declaration_list:
  | declaration declaration_list { $1 :: $2 }
  | declaration                  { [$1] }

declaration:
  | modulex    { $1 }
  | exports   { $1 }
  | fundec    { $1 }
  | recorddec { $1 }
  | uniondec  { $1 }

exports:
  | EXPORT LPAREN exportsList RPAREN { Export $3 }

exportsList:
  | ID COMMA exportsList  { $1 :: $3 }
  | ID                    { [$1] }
  |                       { [] }

modulex:
  | MODULE ID             { Module $2 }

fundec:
  | FUN tyexpr ID LPAREN funargList RPAREN EQUAL expr { FunctionDec {name=$3; template=None; clause=FunctionClause {arguments=$5; body=$8}; returnTy=$2 } }
  | FUN tyexpr ID LTHEN tycaplist GTHEN LPAREN funargList RPAREN EQUAL expr { FunctionDec {name=$3; template=Some $5; clause=FunctionClause {arguments=$8; body=$11}; returnTy=$2}}

funargList:
  | tyexpr ID COMMA funargList  {($1,$2) :: $4}
  | tyexpr ID                   {[($1,$2)]}
  |                             {[]}

tycaplist:
  | TICK ID COMMA tycaplist { match $4 with
                              | Template { tyVars=t; capacityVars=c } -> Template {tyVars=$2::t; capacityVars=c} }
  | ID COMMA tycaplist      { match $3 with
                              | Template { tyVars=t; capacityVars=c } -> Template {tyVars=t; capacityVars=$1::c} }
  | TICK ID                 { Template {tyVars=[$2]; capacityVars=[]} }
  | ID                      { Template {tyVars=[]; capacityVars=[$1]} }

recorddec:
  | TYPE ID EQUAL LCURLYBRACE recordList RCURLYBRACE                       { RecordDec {name=$2; fields=$5; template=None}}
  | TYPE ID LTHEN tycaplist GTHEN EQUAL LCURLYBRACE recordList RCURLYBRACE { RecordDec {name=$2; fields=$8; template=Some $4}}

recordList:
  | tyexpr ID SEMICOLON recordList  {($1, $2) :: $4}
  | tyexpr ID                       {[($1, $2)]}
  |                                 {[]}

uniondec:
  | TYPE ID EQUAL valueConList                       { UnionDec {name=$2; valCons=$4; template=None} }
  | TYPE ID LTHEN tycaplist GTHEN EQUAL valueConList { UnionDec {name=$2; valCons=$7; template=Some $4}}

valueConList:
  | valueCon PIPE valueConList {$1 :: $3}
  | valueCon                   {[$1]}

valueCon:
  | ID LPAREN tyexprList RPAREN {($1, $3)}

expr:
  | expr LPAREN callExprList RPAREN   { CallExp {func=$1; templateArgs=None; args=$3}}
  | ID LTHEN tycaplist GTHEN LPAREN callExprList RPAREN { CallExp {func=VarExp {name=$1}; templateArgs=$3; args=$6} }
  | expr LBRACK expr RBRACK           {ArrayAccessExp {array=$1; index=$3}}
  | LPAREN beginExprList RPAREN       {SequenceExp {exps=$2}}
  | IF expr THEN expr END             {IfExp {condition=$2; trueBranch=$4}}
  | IF expr THEN expr elifList        {()}
  | LET ID EQUAL expr                 {DecLetExp { varName=$2; typ=None; right=$4 }}
  | LET tyexpr ID EQUAL expr	      {DecLetExp { varName=$3; typ=Some $2; right=$5 }
  | VAR ID EQUAL expr                 {DecVarExp { varName=$2; typ=None; right=$4}}
  | VAR tyexpr ID EQUAL expr          {DecVarExp { varName=$3; typ=Some $2; right=$5}}
  | ID EQUAL expr                     {AssignExp { left= VarMutation{varName=$1} ; right=$3}}
  | FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN expr END {()}
  | DO expr WHILE LPAREN expr RPAREN  {()}
  | WHILE LPAREN expr RPAREN expr END {()}
  | module_qualifier                  {()}
  | NOT expr                          {()}
  | TILDE expr                        {()}
  | UNIT                              {()}
  | TRUE                              {()}
  | FALSE                             {()}
  | expr DOT ID                       {()}
  | expr PLUS expr                    {()}
  | expr MINUS expr                   {()}
  | expr TIMES expr                   {()}
  | expr DIVIDE expr                  {()}
  | expr MOD expr                     {()}
  | expr AND expr                     {()}
  | expr OR expr                      {()}
  | expr AMPERSAND expr               {()}
  | expr PIPE expr                    {()}
  | expr GTHENEQ expr                 {()}
  | expr LTHENEQ expr                 {()}
  | expr GTHEN expr                   {()}
  | expr LTHEN expr                   {()}
  | FUN tyexpr ID LPAREN funargList RPAREN MINUS GTHEN expr {()}
  | ID                                {()}
  | INT                               {()}
  | FLOAT                             {()}
  | CASE expr OF caseClauseList END   {()}

caseClauseList:
  | pattern EQUAL GTHEN expr PIPE caseClauseList {()}
  | pattern EQUAL GTHEN expr                     {()}

pattern:
  | INT                                       {()}
  | FLOAT                                     {()}
  | ID                                        {()}
  | UNDERSCORE                                {()}
  | ID LPAREN valConPatternList RPAREN        {()}
  | ID LCURLYBRACE recPatternList RCURLYBRACE {()}

valConPatternList:
  | pattern COMMA valConPatternList {()}
  | pattern                         {()}
  |                                 {()}

recPatternList:
  | ID EQUAL pattern SEMICOLON recPatternList {()}
  | ID EQUAL pattern                          {()}
  |                                           {()}

elifList:
  | ELSE beginExprList END       {()}
  | ELIF beginExprList END       {()}
  | ELIF beginExprList elifList {()}

beginExprList:
  | expr SEMICOLON beginExprList {()}
  | expr                         {()}

callExprList:
  | expr COMMA callExprList {()}
  | expr                    {()}
  |                         {()}  

tyexpr:
  | module_qualifier LTHEN non_empty_tyexprList GTHEN {()}  
  | ID LTHEN non_empty_tyexprList GTHEN               {()}
  | LPAREN tyexprList RPAREN MINUS GTHEN tyexpr       {()}
  | ID                                                {()}

non_empty_tyexprList:
  | tyexpr COMMA non_empty_tyexprList {()}
  | tyexpr                            {()}

tyexprList:
  | tyexpr COMMA tyexprList {()}
  | tyexpr                  {()}
  |                         {()}

module_qualifier:
  | ID COLON COLON ID {()}