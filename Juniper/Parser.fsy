%{
%}

%start start

%token <string> INT
%token <string> FLOAT
%token <string> ID
%token <string> STRING
%token ALIAS
%token RECORD
%token RETURN
%token END
%token OPEN
%token EXPORT
%token MODULE
%token BREAK
%token FUN
%token FN
%token IF
%token THEN
%token ELSE
%token ELIF
%token WHILE
%token DO
%token LET
%token MUTABLE
%token FOR
%token LPAREN
%token RPAREN
%token LBRACK
%token RBRACK
%token LCURLYBRACE
%token RCURLYBRACE
%token COMMA
%token MOD
%token PLUS
%token MINUS
%token TIMES
%token DIVIDE
%token NOT
%token AND
%token OR
%token AMPERSAND
%token PIPE
%token TICK
%token TILDE
%token CASE
%token OF
%token TYPE
%token COLON
%token SEMICOLON
%token NOTEQUAL
%token DOUBLEEQUAL
%token EQUAL
%token GTHAN
%token LTHAN
%token GTHANEQ
%token LTHANEQ
%token UNIT
%token TRUE
%token FALSE
%token UNDERSCORE
%token DOT
%token SET
%token RFATARROW
%token EOF

%type < Module > start

%left SEMICOLON COMMA
%left EQUAL DOUBLEEQUAL NOTEQUAL
%left OR AND
%left UNDERSCORE
%left ID
%left LTHAN LTHANEQ GTHAN GTHANEQ
%left PLUS MINUS PIPE
%left TIMES DIVIDE MOD AMPERSAND
%left NOT TILDE
%left DOT
%left LBRACK
%left LPAREN RPAREN

%%

start:
  | declarationList { Module ($1) }

declarationList:
  | declaration declarationList  { $1 :: $2 }
  |                              { [] }

declaration:
  | moduleNameDec   { $1 }
  | exports         { $1 }
  | fundec          { $1 }
  | recorddec       { $1 }
  | uniondec        { $1 }
  | typealiasdec    { $1 }
  | letdec          { $1 }
  | opendec         { $1 }

opendec:
  | OPEN LPAREN idList RPAREN { OpenDec $3 }

letdec:
  | LET ID EQUAL expr                 { LetDec { varName=$2; typ=None; right=$4; mutable_=false }}
  | LET tyexpr ID EQUAL expr          { LetDec { varName=$3; typ=Some $2; right=$5; mutable_=false }}
  | LET MUTABLE ID EQUAL expr         { LetDec { varName=$3; typ=None; right=$5; mutable_=true }}
  | LET MUTABLE tyexpr ID EQUAL expr  { LetDec { varName=$4; typ=Some $3; right=$6; mutable_=true}}

exports:
  | EXPORT LPAREN idList RPAREN { Export $3 }

typealiasdec:
  | TYPE ALIAS ID EQUAL tyexpr {  TypeAliasDec {name=$3; originalTy=$5; template=None} }
  | TYPE ALIAS ID LTHAN tycapvars GTHAN EQUAL tyexpr {  TypeAliasDec {name=$3; originalTy=$8; template=Some $5} }

moduleNameDec:
  | MODULE ID             { ModuleNameDec $2 }

fundec:
  | FUN tyexpr ID LPAREN funargList RPAREN EQUAL expr {  FunctionDec {name=$3; template=None; clause=FunctionClause {arguments=$5; body=$8}; returnTy=$2 } }
  | FUN tyexpr ID LTHAN tycapvars GTHAN LPAREN funargList RPAREN EQUAL expr {  FunctionDec {name=$3; template=Some $5; clause=FunctionClause {arguments=$8; body=$11}; returnTy=$2}}

funargList:
  | tyexpr ID COMMA funargList  {($1,$2) :: $4}
  | tyexpr ID                   {[($1,$2)]}
  |                             {[]}

tycapvars:
  | idList SEMICOLON idList  { Template {tyVars=$1; capVars=$3} }
  | idList                   { Template {tyVars=$1; capVars=[]} }

idList:
  | ID COMMA idList         { $1::$3 }
  | ID                      { [$1] }
  |                         { [] }

tycapExprs:
  | tyExprs SEMICOLON capExprs {TemplateApply {tyExprs=$1; capExprs=$3}}
  | tyExprs                    {TemplateApply {tyExprs=$1; capExprs=[]}}

tyExprs:
  | tyexpr COMMA tyExprs {$1::$3}
  | tyexpr               {[$1]}
  |                      { [] }

capExprs:
  | capexpr COMMA capExprs  { $1::$3 }
  | capexpr                 { [$1] }
  |                         { [] }

recorddec:
  | TYPE ID EQUAL LCURLYBRACE recordDecList RCURLYBRACE                       { RecordDec {name=$2; fields=$5; template=None}}
  | TYPE ID LTHAN tycapvars GTHAN EQUAL LCURLYBRACE recordDecList RCURLYBRACE { RecordDec {name=$2; fields=$8; template=Some $4}}

recordDecList:
  | tyexpr ID SEMICOLON recordDecList  {($1, $2) :: $4}
  | tyexpr ID                       {[($1, $2)]}
  |                                 {[]}

uniondec:
  | TYPE ID EQUAL valueConList                       { UnionDec {name=$2; valCons=$4; template=None} }
  | TYPE ID LTHAN tycapvars GTHAN EQUAL valueConList { UnionDec {name=$2; valCons=$7; template=Some $4}}

valueConList:
  | valueCon PIPE valueConList {$1 :: $3}
  | valueCon                   {[$1]}
  |                            {[]}

valueCon:
  | ID LPAREN tyexprList RPAREN {($1, $3)}

expr:
  // Calling a function with no templates
  | expr LPAREN callExprList RPAREN   { CallExp {func=$1; templateArgs=None; args=$3}}
  // Calling a function in the same module with a template  
  | ID LTHAN tycapExprs GTHAN LPAREN callExprList RPAREN { CallExp {func=VarExp {name=$1}; templateArgs=Some $3; args=$6} }
  // Calling a function in another module with a template
  | ID COLON ID LTHAN tycapExprs GTHAN LPAREN callExprList RPAREN { CallExp {func=ModQualifierExp {module_=$1; name=$3}; templateArgs=Some $5; args=$8} }
  // Accessing an array element
  | expr LBRACK expr RBRACK           {ArrayAccessExp {array=$1; index=$3}}
  // Sequence of expressions separated by semicolons
  | LPAREN seqExprList RPAREN         {SequenceExp {exps=$2}}
  // If statement with no else
  | IF expr THEN expr END             {IfElseExp {condition=$2; trueBranch=$4; falseBranch=UnitExp}}
  // If statement with elifs and/or else statements
  | IF expr THEN expr elifList        {IfElseExp {condition=$2; trueBranch=$4; falseBranch=$5}}
  // Let statment with type inference
  | LET ID EQUAL expr                 { LetExp { varName=$2; typ=None; right=$4; mutable_=false }}
  // Let statement with type constraint
  | LET tyexpr ID EQUAL expr          { LetExp { varName=$3; typ=Some $2; right=$5; mutable_=false }}
  // Let mutable statement with type inference
  | LET MUTABLE ID EQUAL expr         { LetExp { varName=$3; typ=None; right=$5; mutable_=true }}
  // Let mutable statement without type inference
  | LET MUTABLE tyexpr ID EQUAL expr  { LetExp { varName=$4; typ=Some $3; right=$6; mutable_=true}}
  // Set expression for mutating a variable
  | SET leftAssign EQUAL expr         { AssignExp { left=$2; right=$4 } }
  // For loop
  | FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN expr END {ForLoopExp { init=$3; condition=$5; afterthought=$7 }}
  // Do loop
  | DO expr WHILE LPAREN expr RPAREN  {DoWhileLoopExp {condition=$5; body=$2}}
  | WHILE LPAREN expr RPAREN expr END {WhileLoopExp {condition=$3; body=$5}}
  | moduleQualifier                   {ModQualifierExp $1}
  | NOT expr                          {UnaryOpExp {op=LogicalNot; exp=$2}}
  | TILDE TILDE TILDE expr            {UnaryOpExp {op=BitwiseNot; exp=$4}}
  | UNIT                              {UnitExp}
  | TRUE                              {TrueExp}
  | FALSE                             {FalseExp}
  | expr DOT ID                       {RecordAccessExp {record=$1; fieldName=$3}}
  | expr PLUS expr                    {BinaryOpExp {op=Add; left=$1; right=$3}}
  | expr MINUS expr                   {BinaryOpExp {op=Subtract; left=$1; right=$3}}
  | expr TIMES expr                   {BinaryOpExp {op=Multiply; left=$1; right=$3}}
  | expr DIVIDE expr                  {BinaryOpExp {op=Divide; left=$1; right=$3}}
  | expr MOD expr                     {BinaryOpExp {op=Modulo; left=$1; right=$3}}
  | expr AND expr                     {BinaryOpExp {op=LogicalAnd; left=$1; right=$3}}
  | expr OR expr                      {BinaryOpExp {op=LogicalOr; left=$1; right=$3}}
  | expr AMPERSAND AMPERSAND AMPERSAND expr {BinaryOpExp {op=BitwiseAnd; left=$1; right=$5}}
  | expr PIPE PIPE PIPE expr          {BinaryOpExp {op=BitwiseOr; left=$1; right=$5}}
  | expr GTHANEQ expr                 {BinaryOpExp {op=GreaterOrEqual; left=$1; right=$3}}
  | expr LTHANEQ expr                 {BinaryOpExp {op=LessOrEqual; left=$1; right=$3}}
  | expr GTHAN expr                   {BinaryOpExp {op=Greater; left=$1; right=$3}}
  | expr LTHAN expr                   {BinaryOpExp {op=Less; left=$1; right=$3}}
  | expr DOUBLEEQUAL expr             { BinaryOpExp {op=Equal; left=$1; right=$3}}
  | expr NOTEQUAL expr                {BinaryOpExp {op=NotEqual; left=$1; right=$3}}
  | FN tyexpr LPAREN funargList RPAREN MINUS GTHAN expr { LambdaExp {clause=FunctionClause {arguments=$4; body=$8}; returnTy=$2 }}
  | ID                                { VarExp {name=$1}}
  | INT                               { IntExp $1 }
  | FLOAT                             { FloatExp $1 }
  | CASE expr OF caseClauseList END   { CaseExp {on=$2; clauses=$4}}
  | ID LCURLYBRACE recordInitList RCURLYBRACE          { RecordExp { recordTy=TyName $1; initFields=$3; templateArgs=None } }
  | ID COLON ID LCURLYBRACE recordInitList RCURLYBRACE { RecordExp { recordTy=TyModuleQualifier{module_=$1; name=$3}; initFields=$5; templateArgs=None} }
  | ID LTHAN tycapExprs GTHAN LCURLYBRACE recordInitList RCURLYBRACE          { RecordExp { recordTy=TyName $1; initFields=$6; templateArgs=Some $3 } }
  | ID COLON ID LTHAN tycapExprs GTHAN LCURLYBRACE recordInitList RCURLYBRACE { RecordExp { recordTy=TyModuleQualifier{module_=$1; name=$3}; initFields=$8; templateArgs=Some $5} }
  | LBRACK seqExprList RBRACK         { ListLitExp $2 }

recordInitList:
  | ID EQUAL expr SEMICOLON recordInitList { ($1,$3)::$5 }
  | ID EQUAL expr                          { [($1,$3)] }
  |                                        { [] }

caseClauseList:
  | pattern RFATARROW expr PIPE caseClauseList { ($1, $3)::$5 }
  | pattern RFATARROW expr                     { [($1, $3)] }

pattern:
  | INT                                              { MatchIntVal $1}
  | FLOAT                                            { MatchFloatVal $1}
  | ID                                               { MatchVar $1}
  | UNDERSCORE                                       { MatchUnderscore}
  | ID LPAREN valConPatternList RPAREN               { MatchValCon ($1, $3)}
  | moduleQualifier LPAREN valConPatternList RPAREN  { MatchValConModQualifier ($1, $3)}
  | ID LCURLYBRACE recPatternList RCURLYBRACE        { MatchRecCon ($1, $3)}
  | moduleQualifier LCURLYBRACE recPatternList RCURLYBRACE { MatchRecConModQualifier ($1, $3)}

valConPatternList:
  | pattern COMMA valConPatternList {$1 :: $3}
  | pattern                         {[$1]}
  |                                 {[]}

recPatternList:
  | ID EQUAL pattern SEMICOLON recPatternList { ($1, $3) :: $5}
  | ID EQUAL pattern                          { [($1, $3)]}
  |                                           {[]}

elifList:
  | ELSE expr END                {$2}
  | ELIF expr THEN expr END      {IfElseExp {condition=$2; trueBranch=$4; falseBranch=UnitExp}}
  | ELIF expr THEN expr elifList {IfElseExp {condition=$2; trueBranch=$4; falseBranch=$5}}

seqExprList:
  | expr SEMICOLON seqExprList {$1::$3}
  | expr                       {[$1]}

callExprList:
  | expr COMMA callExprList {$1::$3}
  | expr                    {[$1]}
  |                         {[]}  

tyexpr:
  | moduleQualifier LTHAN nonEmptyTyExprList GTHAN {TyApply {tyConstructor=TyModuleQualifier $1; args=$3}}
  | ID LTHAN nonEmptyTyExprList GTHAN              {TyApply {tyConstructor=TyName $1; args=$3}}
  | LPAREN tyexprList RPAREN MINUS GTHAN tyexpr    {FunTy {args=$2; returnType=$6}}
  | ID LBRACK capexpr RBRACK                       {ArrayTy {valueType=TyName $1; capacity=$3}}
  | moduleQualifier LBRACK capexpr RBRACK          {ArrayTy {valueType=TyModuleQualifier $1; capacity=$3}}
  | ID                                             {match $1 with
                                                        | "uint8" -> BaseTy TyUint8
                                                        | "uint16" -> BaseTy TyUint16
                                                        | "uint32" -> BaseTy TyUint32
                                                        | "uint64" -> BaseTy TyUint64
                                                        | "int8" -> BaseTy TyInt8
                                                        | "int16" -> BaseTy TyInt16
                                                        | "int32" -> BaseTy TyInt32
                                                        | "int64" -> BaseTy TyInt64
                                                        | "bool" -> BaseTy TyBool
                                                        | _ -> TyName $1 }

nonEmptyTyExprList:
  | tyexpr COMMA nonEmptyTyExprList {$1::$3}
  | tyexpr                          {[$1]}

tyexprList:
  | tyexpr COMMA tyexprList {$1::$3}
  | tyexpr                  {[$1]}
  |                         {[]}

capexpr:
  | ID                              { CapacityNameExpr $1}
  | INT                             { CapacityConst $1 }
  | capexpr PLUS   capexpr { CapacityOp {left=$1; op=CAPPLUS; right=$3} }
  | capexpr MINUS  capexpr { CapacityOp {left=$1; op=CAPMINUS; right=$3} }
  | capexpr DIVIDE capexpr { CapacityOp {left=$1; op=CAPDIVIDE; right=$3} }
  | capexpr TIMES  capexpr { CapacityOp {left=$1; op=CAPMULTIPLY; right=$3} }

moduleQualifier:
  | ID COLON ID { {module_=$1; name=$3} }

leftAssign:
  | leftAssign LBRACK expr RBRACK { ArrayMutation {array=$1; index=$3} }
  | leftAssign DOT ID             { RecordMutation {record=$1; fieldName=$3} }
  | ID                            { VarMutation { varName=$1 } }